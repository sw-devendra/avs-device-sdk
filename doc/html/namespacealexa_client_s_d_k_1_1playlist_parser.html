<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: alexaClientSDK::playlistParser Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealexa_client_s_d_k.html">alexaClientSDK</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html">playlistParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::playlistParser Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacealexa_client_s_d_k_1_1playlist_parser_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_content_decrypter.html">ContentDecrypter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_f_f_mpeg_input_buffer.html">FFMpegInputBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_iterative_playlist_parser.html">IterativePlaylistParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html">M3UContent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to encapsulate information retrieved from an M3U playlist.  <a href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_play_item.html">PlayItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_playlist_parser.html">PlaylistParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1playlist_parser_1_1_url_content_to_attachment_converter.html">UrlContentToAttachmentConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that handles the streaming of urls containing media into <code>Attachments</code>.  <a href="classalexa_client_s_d_k_1_1playlist_parser_1_1_url_content_to_attachment_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abb353a54a9bac083933edf0b95d28cbd"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#abb353a54a9bac083933edf0b95d28cbd">ByteVector</a></td></tr>
<tr class="memdesc:abb353a54a9bac083933edf0b95d28cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for bytes.  <a href="#abb353a54a9bac083933edf0b95d28cbd">More...</a><br /></td></tr>
<tr class="separator:abb353a54a9bac083933edf0b95d28cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaa1be6ca1f46fc38087168c7364a35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a1eaa1be6ca1f46fc38087168c7364a35">EVP_CIPHER_CTX_free_ptr</a> = std::unique_ptr&lt; EVP_CIPHER_CTX, decltype(&amp;::EVP_CIPHER_CTX_free)&gt;</td></tr>
<tr class="memdesc:a1eaa1be6ca1f46fc38087168c7364a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique ptr to auto release EVP_CIPHER_CTX.  <a href="#a1eaa1be6ca1f46fc38087168c7364a35">More...</a><br /></td></tr>
<tr class="separator:a1eaa1be6ca1f46fc38087168c7364a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a19913fa969ee9f68005636e86f137318"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a19913fa969ee9f68005636e86f137318">isPlaylistExtendedM3U</a> (const std::string &amp;playlistContent)</td></tr>
<tr class="separator:a19913fa969ee9f68005636e86f137318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5de84beb501cf1ef8298bfec449bf02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html">M3UContent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#af5de84beb501cf1ef8298bfec449bf02">parseM3UContent</a> (const std::string &amp;playlistURL, const std::string &amp;content)</td></tr>
<tr class="separator:af5de84beb501cf1ef8298bfec449bf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af612a94b24a20322e633ef86ae44eb82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser_1_1_encryption_info.html">avsCommon::utils::playlistParser::EncryptionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#af612a94b24a20322e633ef86ae44eb82">parseHLSEncryptionLine</a> (const std::string &amp;line, const std::string &amp;baseURL)</td></tr>
<tr class="separator:af612a94b24a20322e633ef86ae44eb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ab24579bf1d98f3868bef25650398c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser.html#aaf393ec6797d10541b558b52bb9c5514">avsCommon::utils::playlistParser::ByteRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a53ab24579bf1d98f3868bef25650398c">parseHLSByteRangeLine</a> (const std::string &amp;line)</td></tr>
<tr class="separator:a53ab24579bf1d98f3868bef25650398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8450febbe475b0a5a9d834c661275640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser_1_1_playlist_entry.html">avsCommon::utils::playlistParser::PlaylistEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a8450febbe475b0a5a9d834c661275640">parseHLSMapLine</a> (const std::string &amp;line, const std::string &amp;baseURL)</td></tr>
<tr class="separator:a8450febbe475b0a5a9d834c661275640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd69c0a77d5f16e8e132a5d8647aab7b"><td class="memItemLeft" align="right" valign="top">static const std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#afd69c0a77d5f16e8e132a5d8647aab7b">WAIT_FOR_FUTURE_READY_TIMEOUT</a> (100)</td></tr>
<tr class="memdesc:afd69c0a77d5f16e8e132a5d8647aab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout for future ready.  <a href="#afd69c0a77d5f16e8e132a5d8647aab7b">More...</a><br /></td></tr>
<tr class="separator:afd69c0a77d5f16e8e132a5d8647aab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd266a4bb7cd2e11b0e2bbbd252e3d2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#abd266a4bb7cd2e11b0e2bbbd252e3d2a">parsePLSContent</a> (const std::string &amp;playlistURL, const std::string &amp;content)</td></tr>
<tr class="separator:abd266a4bb7cd2e11b0e2bbbd252e3d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b02d4b00e634128dbdfecbd75a511b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a4b02d4b00e634128dbdfecbd75a511b5">removeCarriageReturnFromLine</a> (std::string *line)</td></tr>
<tr class="separator:a4b02d4b00e634128dbdfecbd75a511b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c6e2f2eecf6bc9f58885f95f6521da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a71c6e2f2eecf6bc9f58885f95f6521da">extractPlaylistContent</a> (std::unique_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_h_t_t_p_content.html">avsCommon::utils::HTTPContent</a> &gt; httpContent, std::string *content)</td></tr>
<tr class="separator:a71c6e2f2eecf6bc9f58885f95f6521da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0dac0a6c1b5fa747c9b3ec96dde590"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a0e0dac0a6c1b5fa747c9b3ec96dde590">isURLAbsolute</a> (const std::string &amp;url)</td></tr>
<tr class="separator:a0e0dac0a6c1b5fa747c9b3ec96dde590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc34b2e5077021a1b42555bd2e0a850"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3cc34b2e5077021a1b42555bd2e0a850">getAbsoluteURLFromRelativePathToURL</a> (std::string baseURL, std::string relativePath, std::string *absoluteURL)</td></tr>
<tr class="separator:a3cc34b2e5077021a1b42555bd2e0a850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067efab4d82541ba98c71076054a08fc"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a067efab4d82541ba98c71076054a08fc">TAG</a> (&quot;ContentDecrypter&quot;)</td></tr>
<tr class="memdesc:a067efab4d82541ba98c71076054a08fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">String to identify log entries originating from this file.  <a href="#a067efab4d82541ba98c71076054a08fc">More...</a><br /></td></tr>
<tr class="separator:a067efab4d82541ba98c71076054a08fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64c7b46f50b140486243e6083587600"><td class="memItemLeft" align="right" valign="top">static const std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ae64c7b46f50b140486243e6083587600">WRITE_TO_STREAM_TIMEOUT</a> (100)</td></tr>
<tr class="memdesc:ae64c7b46f50b140486243e6083587600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout for write to stream.  <a href="#ae64c7b46f50b140486243e6083587600">More...</a><br /></td></tr>
<tr class="separator:ae64c7b46f50b140486243e6083587600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1670fb441c1ccc37034b27f6aad35fee"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a1670fb441c1ccc37034b27f6aad35fee">TAG</a> (&quot;IterativePlaylistParser&quot;)</td></tr>
<tr class="memdesc:a1670fb441c1ccc37034b27f6aad35fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">String to identify log entries originating from this file.  <a href="#a1670fb441c1ccc37034b27f6aad35fee">More...</a><br /></td></tr>
<tr class="separator:a1670fb441c1ccc37034b27f6aad35fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcda71b3ad772be7f989fcf90312ce3d"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#adcda71b3ad772be7f989fcf90312ce3d">TAG</a> (&quot;M3UParser&quot;)</td></tr>
<tr class="memdesc:adcda71b3ad772be7f989fcf90312ce3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">String to identify log entries originating from this file.  <a href="#adcda71b3ad772be7f989fcf90312ce3d">More...</a><br /></td></tr>
<tr class="separator:adcda71b3ad772be7f989fcf90312ce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485d36d7c2e0c57fdb6f454d844741df"><td class="memItemLeft" align="right" valign="top">std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a485d36d7c2e0c57fdb6f454d844741df">parseRuntime</a> (std::string line)</td></tr>
<tr class="separator:a485d36d7c2e0c57fdb6f454d844741df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade510e2fff0cc18c71946ce17f0ec1a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ade510e2fff0cc18c71946ce17f0ec1a3">getAbsoluteURL</a> (const std::string &amp;baseURL, const std::string &amp;url, std::string *absoluteURL)</td></tr>
<tr class="separator:ade510e2fff0cc18c71946ce17f0ec1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2eb655f274f34af820e89d4402b297"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3f2eb655f274f34af820e89d4402b297">hasPrefix</a> (const std::string &amp;line, const std::string &amp;prefix)</td></tr>
<tr class="separator:a3f2eb655f274f34af820e89d4402b297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885b33ea12fea3097c9ab188ecc5ed3c"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a885b33ea12fea3097c9ab188ecc5ed3c">to16ByteHexString</a> (int number)</td></tr>
<tr class="separator:a885b33ea12fea3097c9ab188ecc5ed3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdbcb510e7990fa4788fc6ad7332153"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3cdbcb510e7990fa4788fc6ad7332153">parseURIAttribute</a> (const std::string &amp;line, const std::string &amp;baseURL)</td></tr>
<tr class="separator:a3cdbcb510e7990fa4788fc6ad7332153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fed7a3aa94d12e37615fe4e99ff45a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser.html#aaf393ec6797d10541b558b52bb9c5514">ByteRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a8fed7a3aa94d12e37615fe4e99ff45a9">parseByteRange</a> (const std::string &amp;byteRange)</td></tr>
<tr class="separator:a8fed7a3aa94d12e37615fe4e99ff45a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae123030adb2a467a9f67258f158e4c32"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ae123030adb2a467a9f67258f158e4c32">TAG</a> (&quot;PlaylistParser&quot;)</td></tr>
<tr class="memdesc:ae123030adb2a467a9f67258f158e4c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">String to identify log entries originating from this file.  <a href="#ae123030adb2a467a9f67258f158e4c32">More...</a><br /></td></tr>
<tr class="separator:ae123030adb2a467a9f67258f158e4c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8dbc1b5f7e2ef9ae404ef8b2375a03"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a9b8dbc1b5f7e2ef9ae404ef8b2375a03">TAG</a> (&quot;PlaylistUtils&quot;)</td></tr>
<tr class="memdesc:a9b8dbc1b5f7e2ef9ae404ef8b2375a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">String to identify log entries originating from this file.  <a href="#a9b8dbc1b5f7e2ef9ae404ef8b2375a03">More...</a><br /></td></tr>
<tr class="separator:a9b8dbc1b5f7e2ef9ae404ef8b2375a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54daae661ce9d7aa96b3f320e3b0be78"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a54daae661ce9d7aa96b3f320e3b0be78">CHUNK_SIZE</a> (1024)</td></tr>
<tr class="memdesc:a54daae661ce9d7aa96b3f320e3b0be78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes read from the attachment with each read in the read loop.  <a href="#a54daae661ce9d7aa96b3f320e3b0be78">More...</a><br /></td></tr>
<tr class="separator:a54daae661ce9d7aa96b3f320e3b0be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892cb957e241574bf00fa611eae671c5"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a892cb957e241574bf00fa611eae671c5">TAG</a> (&quot;UrlContentToAttachmentConverter&quot;)</td></tr>
<tr class="memdesc:a892cb957e241574bf00fa611eae671c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">String to identify log entries originating from this file.  <a href="#a892cb957e241574bf00fa611eae671c5">More...</a><br /></td></tr>
<tr class="separator:a892cb957e241574bf00fa611eae671c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd69c0a77d5f16e8e132a5d8647aab7b"><td class="memItemLeft" align="right" valign="top">static const std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#afd69c0a77d5f16e8e132a5d8647aab7b">WAIT_FOR_FUTURE_READY_TIMEOUT</a> (100)</td></tr>
<tr class="memdesc:afd69c0a77d5f16e8e132a5d8647aab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout for future ready.  <a href="#afd69c0a77d5f16e8e132a5d8647aab7b">More...</a><br /></td></tr>
<tr class="separator:afd69c0a77d5f16e8e132a5d8647aab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54daae661ce9d7aa96b3f320e3b0be78"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a54daae661ce9d7aa96b3f320e3b0be78">CHUNK_SIZE</a> (1024)</td></tr>
<tr class="memdesc:a54daae661ce9d7aa96b3f320e3b0be78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes read from the attachment with each read in the read loop.  <a href="#a54daae661ce9d7aa96b3f320e3b0be78">More...</a><br /></td></tr>
<tr class="separator:a54daae661ce9d7aa96b3f320e3b0be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3e3639b87eef2155b0633c1defa38cc9"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3e3639b87eef2155b0633c1defa38cc9">AES_BLOCK_SIZE</a> = 16</td></tr>
<tr class="memdesc:a3e3639b87eef2155b0633c1defa38cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block size of AES encrypted content.  <a href="#a3e3639b87eef2155b0633c1defa38cc9">More...</a><br /></td></tr>
<tr class="separator:a3e3639b87eef2155b0633c1defa38cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ed9058e8d03b5893842bd0a23b0f7b"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ab5ed9058e8d03b5893842bd0a23b0f7b">IV_HEX_STRING_LENGTH</a> = 2 * <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3e3639b87eef2155b0633c1defa38cc9">AES_BLOCK_SIZE</a></td></tr>
<tr class="memdesc:ab5ed9058e8d03b5893842bd0a23b0f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of initilization vector as hex string.  <a href="#ab5ed9058e8d03b5893842bd0a23b0f7b">More...</a><br /></td></tr>
<tr class="separator:ab5ed9058e8d03b5893842bd0a23b0f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad08a5365795a653696041261c98ab67"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#aad08a5365795a653696041261c98ab67">M3U_CONTENT_TYPE</a> = &quot;mpegurl&quot;</td></tr>
<tr class="memdesc:aad08a5365795a653696041261c98ab67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HTML content-type of an M3U playlist.  <a href="#aad08a5365795a653696041261c98ab67">More...</a><br /></td></tr>
<tr class="separator:aad08a5365795a653696041261c98ab67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d8a300fc90d8a970d8fc786089e718"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ae2d8a300fc90d8a970d8fc786089e718">PLS_CONTENT_TYPE</a> = &quot;scpls&quot;</td></tr>
<tr class="memdesc:ae2d8a300fc90d8a970d8fc786089e718"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HTML content-type of a PLS playlist.  <a href="#ae2d8a300fc90d8a970d8fc786089e718">More...</a><br /></td></tr>
<tr class="separator:ae2d8a300fc90d8a970d8fc786089e718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ad6e1d33017a9c5e810e4365d006c0c6a">INVALID_DURATION</a> = std::chrono::milliseconds(-1)</td></tr>
<tr class="memdesc:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid duration.  <a href="#ad6e1d33017a9c5e810e4365d006c0c6a">More...</a><br /></td></tr>
<tr class="separator:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e4a1b6bdccf19778918d4b3771358a"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a73e4a1b6bdccf19778918d4b3771358a">EXT_M3U_PLAYLIST_HEADER</a> = &quot;#EXTM3U&quot;</td></tr>
<tr class="memdesc:a73e4a1b6bdccf19778918d4b3771358a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first line of an Extended M3U playlist.  <a href="#a73e4a1b6bdccf19778918d4b3771358a">More...</a><br /></td></tr>
<tr class="separator:a73e4a1b6bdccf19778918d4b3771358a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15abf8e2c38db64ace8c6779151ea20b"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a15abf8e2c38db64ace8c6779151ea20b">EXTINF</a> = &quot;#EXTINF&quot;</td></tr>
<tr class="memdesc:a15abf8e2c38db64ace8c6779151ea20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLS <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a15abf8e2c38db64ace8c6779151ea20b" title="HLS EXTINF tag. ">EXTINF</a> tag.  <a href="#a15abf8e2c38db64ace8c6779151ea20b">More...</a><br /></td></tr>
<tr class="separator:a15abf8e2c38db64ace8c6779151ea20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f68879bcf44039d56c5b65db5195dd4"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a5f68879bcf44039d56c5b65db5195dd4">EXTSTREAMINF</a> = &quot;#EXT-X-STREAM-INF&quot;</td></tr>
<tr class="separator:a5f68879bcf44039d56c5b65db5195dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d0209a92b8c7a230607470c384c205"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a14d0209a92b8c7a230607470c384c205">ENDLIST</a> = &quot;#EXT-X-ENDLIST&quot;</td></tr>
<tr class="separator:a14d0209a92b8c7a230607470c384c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52ac01800f2c973939d1f049988197"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#aea52ac01800f2c973939d1f049988197">EXT_KEY</a> = &quot;#EXT-X-KEY:&quot;</td></tr>
<tr class="memdesc:aea52ac01800f2c973939d1f049988197"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXT-X-KEY HLS tag.  <a href="#aea52ac01800f2c973939d1f049988197">More...</a><br /></td></tr>
<tr class="separator:aea52ac01800f2c973939d1f049988197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af308dff8536e5d2df27f1fba145ceeaa"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#af308dff8536e5d2df27f1fba145ceeaa">EXT_MAP</a> = &quot;#EXT-X-MAP:&quot;</td></tr>
<tr class="memdesc:af308dff8536e5d2df27f1fba145ceeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXT-X-MAP HLS tag.  <a href="#af308dff8536e5d2df27f1fba145ceeaa">More...</a><br /></td></tr>
<tr class="separator:af308dff8536e5d2df27f1fba145ceeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c659b07cddd37bfac16caddabfe058"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a31c659b07cddd37bfac16caddabfe058">EXT_BYTERANGE</a> = &quot;#EXT-X-BYTERANGE:&quot;</td></tr>
<tr class="memdesc:a31c659b07cddd37bfac16caddabfe058"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXT-X-BYTERANGE HLS tag.  <a href="#a31c659b07cddd37bfac16caddabfe058">More...</a><br /></td></tr>
<tr class="separator:a31c659b07cddd37bfac16caddabfe058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de330d59c114114a8c4ccec1dda60a0"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a0de330d59c114114a8c4ccec1dda60a0">METHOD_ATTR</a> = &quot;METHOD=&quot;</td></tr>
<tr class="memdesc:a0de330d59c114114a8c4ccec1dda60a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method encryption attribute.  <a href="#a0de330d59c114114a8c4ccec1dda60a0">More...</a><br /></td></tr>
<tr class="separator:a0de330d59c114114a8c4ccec1dda60a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada27ee87af91eab7d05cb1bc765c7b05"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ada27ee87af91eab7d05cb1bc765c7b05">URI_ATTR</a> = &quot;URI=\&quot;&quot;</td></tr>
<tr class="memdesc:ada27ee87af91eab7d05cb1bc765c7b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">HLS tag attribute for URI.  <a href="#ada27ee87af91eab7d05cb1bc765c7b05">More...</a><br /></td></tr>
<tr class="separator:ada27ee87af91eab7d05cb1bc765c7b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823eac033e683f739d8291936e992949"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a823eac033e683f739d8291936e992949">IV_ATTR</a> = &quot;IV=&quot;</td></tr>
<tr class="memdesc:a823eac033e683f739d8291936e992949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization Vector encryption attribute.  <a href="#a823eac033e683f739d8291936e992949">More...</a><br /></td></tr>
<tr class="separator:a823eac033e683f739d8291936e992949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfe3d543fdaa34d3d90f229ada663d0"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3bfe3d543fdaa34d3d90f229ada663d0">BYTERANGE_ATTR</a> = &quot;BYTERANGE=\&quot;&quot;</td></tr>
<tr class="memdesc:a3bfe3d543fdaa34d3d90f229ada663d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte range encryption attribute.  <a href="#a3bfe3d543fdaa34d3d90f229ada663d0">More...</a><br /></td></tr>
<tr class="separator:a3bfe3d543fdaa34d3d90f229ada663d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaf62a2c22bd8372f606b50eb81cf3b"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#adeaf62a2c22bd8372f606b50eb81cf3b">ENCRYPTION_METHOD_NONE</a> = &quot;NONE&quot;</td></tr>
<tr class="memdesc:adeaf62a2c22bd8372f606b50eb81cf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encryption method: NONE.  <a href="#adeaf62a2c22bd8372f606b50eb81cf3b">More...</a><br /></td></tr>
<tr class="separator:adeaf62a2c22bd8372f606b50eb81cf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec575cc222a2dd65e5772834b4a9850"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a8ec575cc222a2dd65e5772834b4a9850">ENCRYPTION_METHOD_AES_128</a> = &quot;AES-128&quot;</td></tr>
<tr class="memdesc:a8ec575cc222a2dd65e5772834b4a9850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encryption method: AES-128.  <a href="#a8ec575cc222a2dd65e5772834b4a9850">More...</a><br /></td></tr>
<tr class="separator:a8ec575cc222a2dd65e5772834b4a9850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae452a94063724fa0571f6b93f49b3d86"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ae452a94063724fa0571f6b93f49b3d86">ENCRYPTION_METHOD_SAMPLE_AES</a> = &quot;SAMPLE-AES&quot;</td></tr>
<tr class="memdesc:ae452a94063724fa0571f6b93f49b3d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encryption method: SAMPLE-AES.  <a href="#ae452a94063724fa0571f6b93f49b3d86">More...</a><br /></td></tr>
<tr class="separator:ae452a94063724fa0571f6b93f49b3d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ad6e1d33017a9c5e810e4365d006c0c6a">INVALID_DURATION</a> = std::chrono::milliseconds(-1)</td></tr>
<tr class="memdesc:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid duration.  <a href="#ad6e1d33017a9c5e810e4365d006c0c6a">More...</a><br /></td></tr>
<tr class="separator:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ed9058e8d03b5893842bd0a23b0f7b"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ab5ed9058e8d03b5893842bd0a23b0f7b">IV_HEX_STRING_LENGTH</a> = 32</td></tr>
<tr class="memdesc:ab5ed9058e8d03b5893842bd0a23b0f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of initialization vector as hex string.  <a href="#ab5ed9058e8d03b5893842bd0a23b0f7b">More...</a><br /></td></tr>
<tr class="separator:ab5ed9058e8d03b5893842bd0a23b0f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad08a5365795a653696041261c98ab67"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#aad08a5365795a653696041261c98ab67">M3U_CONTENT_TYPE</a> = &quot;mpegurl&quot;</td></tr>
<tr class="memdesc:aad08a5365795a653696041261c98ab67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HTML content-type of an M3U playlist.  <a href="#aad08a5365795a653696041261c98ab67">More...</a><br /></td></tr>
<tr class="separator:aad08a5365795a653696041261c98ab67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d8a300fc90d8a970d8fc786089e718"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ae2d8a300fc90d8a970d8fc786089e718">PLS_CONTENT_TYPE</a> = &quot;scpls&quot;</td></tr>
<tr class="memdesc:ae2d8a300fc90d8a970d8fc786089e718"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HTML content-type of a PLS playlist.  <a href="#ae2d8a300fc90d8a970d8fc786089e718">More...</a><br /></td></tr>
<tr class="separator:ae2d8a300fc90d8a970d8fc786089e718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863b8b4734d96a7f29deda10473fae14"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a863b8b4734d96a7f29deda10473fae14">g_id</a> = 0</td></tr>
<tr class="memdesc:a863b8b4734d96a7f29deda10473fae14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id of each request.  <a href="#a863b8b4734d96a7f29deda10473fae14">More...</a><br /></td></tr>
<tr class="separator:a863b8b4734d96a7f29deda10473fae14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ad6e1d33017a9c5e810e4365d006c0c6a">INVALID_DURATION</a> = std::chrono::milliseconds(-1)</td></tr>
<tr class="memdesc:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid duration.  <a href="#ad6e1d33017a9c5e810e4365d006c0c6a">More...</a><br /></td></tr>
<tr class="separator:ad6e1d33017a9c5e810e4365d006c0c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb8f02e86db841d2ea55658c433b86a"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a0eb8f02e86db841d2ea55658c433b86a">PLS_PLAYLIST_HEADER</a> = &quot;[playlist]&quot;</td></tr>
<tr class="memdesc:a0eb8f02e86db841d2ea55658c433b86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first line of a PLS playlist.  <a href="#a0eb8f02e86db841d2ea55658c433b86a">More...</a><br /></td></tr>
<tr class="separator:a0eb8f02e86db841d2ea55658c433b86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ea523dee7ebdc160762ddcd7ff59c8"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#ae4ea523dee7ebdc160762ddcd7ff59c8">PLS_FILE</a> = &quot;File&quot;</td></tr>
<tr class="memdesc:ae4ea523dee7ebdc160762ddcd7ff59c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The beginning of a line in a PLS file indicating a URL.  <a href="#ae4ea523dee7ebdc160762ddcd7ff59c8">More...</a><br /></td></tr>
<tr class="separator:ae4ea523dee7ebdc160762ddcd7ff59c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e77b880934e6f5e7a6d4e65f4c4fdb1"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3e77b880934e6f5e7a6d4e65f4c4fdb1">URL_END_SCHEME_PATTERN</a> = &quot;://&quot;</td></tr>
<tr class="memdesc:a3e77b880934e6f5e7a6d4e65f4c4fdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">url scheme pattern.  <a href="#a3e77b880934e6f5e7a6d4e65f4c4fdb1">More...</a><br /></td></tr>
<tr class="separator:a3e77b880934e6f5e7a6d4e65f4c4fdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44068fd7f1c56d94e4c557ffe57ea24a"><td class="memItemLeft" align="right" valign="top">static const std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a44068fd7f1c56d94e4c557ffe57ea24a">INVALID_DURATION</a> = std::chrono::milliseconds(-1)</td></tr>
<tr class="memdesc:a44068fd7f1c56d94e4c557ffe57ea24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid duration.  <a href="#a44068fd7f1c56d94e4c557ffe57ea24a">More...</a><br /></td></tr>
<tr class="separator:a44068fd7f1c56d94e4c557ffe57ea24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abb353a54a9bac083933edf0b95d28cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb353a54a9bac083933edf0b95d28cbd">&#9670;&nbsp;</a></span>ByteVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;unsigned char&gt; <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#abb353a54a9bac083933edf0b95d28cbd">alexaClientSDK::playlistParser::ByteVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for bytes. </p>

</div>
</div>
<a id="a1eaa1be6ca1f46fc38087168c7364a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaa1be6ca1f46fc38087168c7364a35">&#9670;&nbsp;</a></span>EVP_CIPHER_CTX_free_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a1eaa1be6ca1f46fc38087168c7364a35">alexaClientSDK::playlistParser::EVP_CIPHER_CTX_free_ptr</a> = typedef std::unique_ptr&lt;EVP_CIPHER_CTX, decltype(&amp;::EVP_CIPHER_CTX_free)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique ptr to auto release EVP_CIPHER_CTX. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a54daae661ce9d7aa96b3f320e3b0be78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54daae661ce9d7aa96b3f320e3b0be78">&#9670;&nbsp;</a></span>CHUNK_SIZE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const size_t alexaClientSDK::playlistParser::CHUNK_SIZE </td>
          <td>(</td>
          <td class="paramtype">1024&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes read from the attachment with each read in the read loop. </p>

</div>
</div>
<a id="a54daae661ce9d7aa96b3f320e3b0be78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54daae661ce9d7aa96b3f320e3b0be78">&#9670;&nbsp;</a></span>CHUNK_SIZE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const size_t alexaClientSDK::playlistParser::CHUNK_SIZE </td>
          <td>(</td>
          <td class="paramtype">1024&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes read from the attachment with each read in the read loop. </p>

</div>
</div>
<a id="a71c6e2f2eecf6bc9f58885f95f6521da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c6e2f2eecf6bc9f58885f95f6521da">&#9670;&nbsp;</a></span>extractPlaylistContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::extractPlaylistContent </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1utils_1_1_h_t_t_p_content.html">avsCommon::utils::HTTPContent</a> &gt;&#160;</td>
          <td class="paramname"><em>httpContent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves playlist content and stores it into a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">httpContent</td><td>Object used to retrieve url content. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">content</td><td>The playlist content. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no error occured or <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used to retrieve content specifically from playlist URLs. Attempting to use this on a media URL could be blocking forever as the URL might point to a live stream. </dd></dl>

</div>
</div>
<a id="ade510e2fff0cc18c71946ce17f0ec1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade510e2fff0cc18c71946ce17f0ec1a3">&#9670;&nbsp;</a></span>getAbsoluteURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::getAbsoluteURL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>absoluteURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper method to convert a line in HLS playlist to absolute URL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baseURL</td><td>The URL of the HLS playlist. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">url</td><td>The URL found in HLS playlist. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">absoluteURL</td><td>Absolute URL parsed from <code>line</code> and converted to an absolute URL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if method is successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3cc34b2e5077021a1b42555bd2e0a850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc34b2e5077021a1b42555bd2e0a850">&#9670;&nbsp;</a></span>getAbsoluteURLFromRelativePathToURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::getAbsoluteURLFromRelativePathToURL </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>baseURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>relativePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>absoluteURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an absolute url, given a base url and a relative path from that url. For example, if "www.awesomewebsite.com/music/test.m3u" was the base url and the relative path was "music.mp3", "www.awesomewebsite.com/music/music.mp3" would be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baseURL</td><td>The base url to add the relative path to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">relativePath</td><td>The relative path to add to the base url. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">absoluteURL</td><td>The absolute url generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> If everything was successful and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3f2eb655f274f34af820e89d4402b297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2eb655f274f34af820e89d4402b297">&#9670;&nbsp;</a></span>hasPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::hasPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper method to check if line starts with prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>A HLS line. </td></tr>
    <tr><td class="paramname">prefix</td><td>The prefix to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>line</code> starts with <code>prefix</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a19913fa969ee9f68005636e86f137318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19913fa969ee9f68005636e86f137318">&#9670;&nbsp;</a></span>isPlaylistExtendedM3U()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::isPlaylistExtendedM3U </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>playlistContent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the playlist type of an M3U playlist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playlistContent</td><td>The M3U playlist in <code>std::string</code> format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the playlist is extended M3U or <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a0e0dac0a6c1b5fa747c9b3ec96dde590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0dac0a6c1b5fa747c9b3ec96dde590">&#9670;&nbsp;</a></span>isURLAbsolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::playlistParser::isURLAbsolute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether the provided url is an absolute url as opposed to a relative url. This is done by simply checking to see if the string contains the substring "://".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The url to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the url is an absolute url and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8fed7a3aa94d12e37615fe4e99ff45a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fed7a3aa94d12e37615fe4e99ff45a9">&#9670;&nbsp;</a></span>parseByteRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser.html#aaf393ec6797d10541b558b52bb9c5514">ByteRange</a> alexaClientSDK::playlistParser::parseByteRange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>byteRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53ab24579bf1d98f3868bef25650398c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ab24579bf1d98f3868bef25650398c">&#9670;&nbsp;</a></span>parseHLSByteRangeLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser.html#aaf393ec6797d10541b558b52bb9c5514">ByteRange</a> alexaClientSDK::playlistParser::parseHLSByteRangeLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses #EXT-X-BYTERANGE line of HLS playlist and returns <code>ByteRange</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>ByteRange</code> - {start, end}. </dd></dl>

</div>
</div>
<a id="af612a94b24a20322e633ef86ae44eb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af612a94b24a20322e633ef86ae44eb82">&#9670;&nbsp;</a></span>parseHLSEncryptionLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser_1_1_encryption_info.html">EncryptionInfo</a> alexaClientSDK::playlistParser::parseHLSEncryptionLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses #EXT-X-KEY line of HLS playlist and returns <code>EncryptionInfo</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to parse. </td></tr>
    <tr><td class="paramname">baseURL</td><td>The URL of the playlist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>EncryptionInfo</code>. </dd></dl>

</div>
</div>
<a id="a8450febbe475b0a5a9d834c661275640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8450febbe475b0a5a9d834c661275640">&#9670;&nbsp;</a></span>parseHLSMapLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalexa_client_s_d_k_1_1avs_common_1_1utils_1_1playlist_parser_1_1_playlist_entry.html">PlaylistEntry</a> alexaClientSDK::playlistParser::parseHLSMapLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses #EXT-X-MAP line of HLS playlist and returns <code>PlaylistEntry</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to parse. </td></tr>
    <tr><td class="paramname">baseURL</td><td>The url of the playlist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>PlaylistEntry</code>. </dd></dl>

</div>
</div>
<a id="af5de84beb501cf1ef8298bfec449bf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5de84beb501cf1ef8298bfec449bf02">&#9670;&nbsp;</a></span>parseM3UContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html">M3UContent</a> alexaClientSDK::playlistParser::parseM3UContent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>playlistURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an M3U playlist and returns the "children" URLs in the order they appeared in the playlist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">playlistURL</td><td>The URL of the M3U playlist that needs to be parsed. </td></tr>
    <tr><td class="paramname">content</td><td>Text content of the downloaded M3U playlist to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="structalexa_client_s_d_k_1_1playlist_parser_1_1_m3_u_content.html" title="A struct used to encapsulate information retrieved from an M3U playlist. ">M3UContent</a></code> which contains parsed list of variant URLs (for master playlist) OR list of @ Playlist (for media playlist). </dd></dl>

</div>
</div>
<a id="abd266a4bb7cd2e11b0e2bbbd252e3d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd266a4bb7cd2e11b0e2bbbd252e3d2a">&#9670;&nbsp;</a></span>parsePLSContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; alexaClientSDK::playlistParser::parsePLSContent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>playlistURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an PLS playlist and returns the "children" URLs in the order they appeared in the playlist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The content to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of URLs in the order they appeared in the playlist. </dd></dl>

</div>
</div>
<a id="a485d36d7c2e0c57fdb6f454d844741df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485d36d7c2e0c57fdb6f454d844741df">&#9670;&nbsp;</a></span>parseRuntime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::milliseconds alexaClientSDK::playlistParser::parseRuntime </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper method to parse runtime from <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a15abf8e2c38db64ace8c6779151ea20b" title="HLS EXTINF tag. ">EXTINF</a> tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a15abf8e2c38db64ace8c6779151ea20b" title="HLS EXTINF tag. ">EXTINF</a> line in HLS playlist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed runtime in milliseconds from line. </dd></dl>

</div>
</div>
<a id="a3cdbcb510e7990fa4788fc6ad7332153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdbcb510e7990fa4788fc6ad7332153">&#9670;&nbsp;</a></span>parseURIAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexaClientSDK::playlistParser::parseURIAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseURL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b02d4b00e634128dbdfecbd75a511b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b02d4b00e634128dbdfecbd75a511b5">&#9670;&nbsp;</a></span>removeCarriageReturnFromLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexaClientSDK::playlistParser::removeCarriageReturnFromLine </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a carriage return from the end of a line. This is required to handle Windows style line breaks ('<br />
'). std::getline reads by default up to '<br />
' so at times, the '' may be included when readinglines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line to parse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b8dbc1b5f7e2ef9ae404ef8b2375a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8dbc1b5f7e2ef9ae404ef8b2375a03">&#9670;&nbsp;</a></span>TAG() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string alexaClientSDK::playlistParser::TAG </td>
          <td>(</td>
          <td class="paramtype">&quot;PlaylistUtils&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String to identify log entries originating from this file. </p>

</div>
</div>
<a id="a892cb957e241574bf00fa611eae671c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892cb957e241574bf00fa611eae671c5">&#9670;&nbsp;</a></span>TAG() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string alexaClientSDK::playlistParser::TAG </td>
          <td>(</td>
          <td class="paramtype">&quot;UrlContentToAttachmentConverter&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String to identify log entries originating from this file. </p>

</div>
</div>
<a id="adcda71b3ad772be7f989fcf90312ce3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcda71b3ad772be7f989fcf90312ce3d">&#9670;&nbsp;</a></span>TAG() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string alexaClientSDK::playlistParser::TAG </td>
          <td>(</td>
          <td class="paramtype">&quot;M3UParser&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String to identify log entries originating from this file. </p>

</div>
</div>
<a id="a1670fb441c1ccc37034b27f6aad35fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1670fb441c1ccc37034b27f6aad35fee">&#9670;&nbsp;</a></span>TAG() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string alexaClientSDK::playlistParser::TAG </td>
          <td>(</td>
          <td class="paramtype">&quot;IterativePlaylistParser&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String to identify log entries originating from this file. </p>

</div>
</div>
<a id="ae123030adb2a467a9f67258f158e4c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae123030adb2a467a9f67258f158e4c32">&#9670;&nbsp;</a></span>TAG() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string alexaClientSDK::playlistParser::TAG </td>
          <td>(</td>
          <td class="paramtype">&quot;PlaylistParser&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String to identify log entries originating from this file. </p>

</div>
</div>
<a id="a067efab4d82541ba98c71076054a08fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067efab4d82541ba98c71076054a08fc">&#9670;&nbsp;</a></span>TAG() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string alexaClientSDK::playlistParser::TAG </td>
          <td>(</td>
          <td class="paramtype">&quot;ContentDecrypter&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String to identify log entries originating from this file. </p>

</div>
</div>
<a id="a885b33ea12fea3097c9ab188ecc5ed3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885b33ea12fea3097c9ab188ecc5ed3c">&#9670;&nbsp;</a></span>to16ByteHexString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string alexaClientSDK::playlistParser::to16ByteHexString </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd69c0a77d5f16e8e132a5d8647aab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd69c0a77d5f16e8e132a5d8647aab7b">&#9670;&nbsp;</a></span>WAIT_FOR_FUTURE_READY_TIMEOUT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::chrono::milliseconds alexaClientSDK::playlistParser::WAIT_FOR_FUTURE_READY_TIMEOUT </td>
          <td>(</td>
          <td class="paramtype">100&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timeout for future ready. </p>

</div>
</div>
<a id="afd69c0a77d5f16e8e132a5d8647aab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd69c0a77d5f16e8e132a5d8647aab7b">&#9670;&nbsp;</a></span>WAIT_FOR_FUTURE_READY_TIMEOUT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::chrono::milliseconds alexaClientSDK::playlistParser::WAIT_FOR_FUTURE_READY_TIMEOUT </td>
          <td>(</td>
          <td class="paramtype">100&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timeout for future ready. </p>

</div>
</div>
<a id="ae64c7b46f50b140486243e6083587600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64c7b46f50b140486243e6083587600">&#9670;&nbsp;</a></span>WRITE_TO_STREAM_TIMEOUT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::chrono::milliseconds alexaClientSDK::playlistParser::WRITE_TO_STREAM_TIMEOUT </td>
          <td>(</td>
          <td class="paramtype">100&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timeout for write to stream. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3e3639b87eef2155b0633c1defa38cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3639b87eef2155b0633c1defa38cc9">&#9670;&nbsp;</a></span>AES_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int alexaClientSDK::playlistParser::AES_BLOCK_SIZE = 16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block size of AES encrypted content. </p>

</div>
</div>
<a id="a3bfe3d543fdaa34d3d90f229ada663d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfe3d543fdaa34d3d90f229ada663d0">&#9670;&nbsp;</a></span>BYTERANGE_ATTR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::BYTERANGE_ATTR = &quot;BYTERANGE=\&quot;&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Byte range encryption attribute. </p>

</div>
</div>
<a id="a8ec575cc222a2dd65e5772834b4a9850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec575cc222a2dd65e5772834b4a9850">&#9670;&nbsp;</a></span>ENCRYPTION_METHOD_AES_128</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::ENCRYPTION_METHOD_AES_128 = &quot;AES-128&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encryption method: AES-128. </p>

</div>
</div>
<a id="adeaf62a2c22bd8372f606b50eb81cf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaf62a2c22bd8372f606b50eb81cf3b">&#9670;&nbsp;</a></span>ENCRYPTION_METHOD_NONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::ENCRYPTION_METHOD_NONE = &quot;NONE&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encryption method: NONE. </p>

</div>
</div>
<a id="ae452a94063724fa0571f6b93f49b3d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae452a94063724fa0571f6b93f49b3d86">&#9670;&nbsp;</a></span>ENCRYPTION_METHOD_SAMPLE_AES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::ENCRYPTION_METHOD_SAMPLE_AES = &quot;SAMPLE-AES&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encryption method: SAMPLE-AES. </p>

</div>
</div>
<a id="a14d0209a92b8c7a230607470c384c205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d0209a92b8c7a230607470c384c205">&#9670;&nbsp;</a></span>ENDLIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::ENDLIST = &quot;#EXT-X-ENDLIST&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A tag present in a live stream playlist indicating that no more URLs will be added to the playlist on subsequent requests. </p>

</div>
</div>
<a id="a31c659b07cddd37bfac16caddabfe058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c659b07cddd37bfac16caddabfe058">&#9670;&nbsp;</a></span>EXT_BYTERANGE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::EXT_BYTERANGE = &quot;#EXT-X-BYTERANGE:&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>EXT-X-BYTERANGE HLS tag. </p>

</div>
</div>
<a id="aea52ac01800f2c973939d1f049988197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea52ac01800f2c973939d1f049988197">&#9670;&nbsp;</a></span>EXT_KEY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::EXT_KEY = &quot;#EXT-X-KEY:&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>EXT-X-KEY HLS tag. </p>

</div>
</div>
<a id="a73e4a1b6bdccf19778918d4b3771358a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e4a1b6bdccf19778918d4b3771358a">&#9670;&nbsp;</a></span>EXT_M3U_PLAYLIST_HEADER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::EXT_M3U_PLAYLIST_HEADER = &quot;#EXTM3U&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first line of an Extended M3U playlist. </p>

</div>
</div>
<a id="af308dff8536e5d2df27f1fba145ceeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af308dff8536e5d2df27f1fba145ceeaa">&#9670;&nbsp;</a></span>EXT_MAP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::EXT_MAP = &quot;#EXT-X-MAP:&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>EXT-X-MAP HLS tag. </p>

</div>
</div>
<a id="a15abf8e2c38db64ace8c6779151ea20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15abf8e2c38db64ace8c6779151ea20b">&#9670;&nbsp;</a></span>EXTINF</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::EXTINF = &quot;#EXTINF&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>HLS <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a15abf8e2c38db64ace8c6779151ea20b" title="HLS EXTINF tag. ">EXTINF</a> tag. </p>

</div>
</div>
<a id="a5f68879bcf44039d56c5b65db5195dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f68879bcf44039d56c5b65db5195dd4">&#9670;&nbsp;</a></span>EXTSTREAMINF</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::EXTSTREAMINF = &quot;#EXT-X-STREAM-INF&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A tag present in a live stream playlist that indicates that the next URL points to a playlist. Attributes of this tag include information such as bitrate, codecs, and others. </p>

</div>
</div>
<a id="a863b8b4734d96a7f29deda10473fae14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863b8b4734d96a7f29deda10473fae14">&#9670;&nbsp;</a></span>g_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int alexaClientSDK::playlistParser::g_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The id of each request. </p>

</div>
</div>
<a id="a44068fd7f1c56d94e4c557ffe57ea24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44068fd7f1c56d94e4c557ffe57ea24a">&#9670;&nbsp;</a></span>INVALID_DURATION <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::chrono::milliseconds alexaClientSDK::playlistParser::INVALID_DURATION = std::chrono::milliseconds(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An invalid duration. </p>

</div>
</div>
<a id="ad6e1d33017a9c5e810e4365d006c0c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e1d33017a9c5e810e4365d006c0c6a">&#9670;&nbsp;</a></span>INVALID_DURATION <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto alexaClientSDK::playlistParser::INVALID_DURATION = std::chrono::milliseconds(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An invalid duration. </p>

</div>
</div>
<a id="ad6e1d33017a9c5e810e4365d006c0c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e1d33017a9c5e810e4365d006c0c6a">&#9670;&nbsp;</a></span>INVALID_DURATION <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto alexaClientSDK::playlistParser::INVALID_DURATION = std::chrono::milliseconds(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An invalid duration. </p>

</div>
</div>
<a id="ad6e1d33017a9c5e810e4365d006c0c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e1d33017a9c5e810e4365d006c0c6a">&#9670;&nbsp;</a></span>INVALID_DURATION <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto alexaClientSDK::playlistParser::INVALID_DURATION = std::chrono::milliseconds(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An invalid duration. </p>

</div>
</div>
<a id="a823eac033e683f739d8291936e992949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823eac033e683f739d8291936e992949">&#9670;&nbsp;</a></span>IV_ATTR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::IV_ATTR = &quot;IV=&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization Vector encryption attribute. </p>

</div>
</div>
<a id="ab5ed9058e8d03b5893842bd0a23b0f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ed9058e8d03b5893842bd0a23b0f7b">&#9670;&nbsp;</a></span>IV_HEX_STRING_LENGTH <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int alexaClientSDK::playlistParser::IV_HEX_STRING_LENGTH = 2 * <a class="el" href="namespacealexa_client_s_d_k_1_1playlist_parser.html#a3e3639b87eef2155b0633c1defa38cc9">AES_BLOCK_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Length of initilization vector as hex string. </p>

</div>
</div>
<a id="ab5ed9058e8d03b5893842bd0a23b0f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ed9058e8d03b5893842bd0a23b0f7b">&#9670;&nbsp;</a></span>IV_HEX_STRING_LENGTH <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int alexaClientSDK::playlistParser::IV_HEX_STRING_LENGTH = 32</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Length of initialization vector as hex string. </p>

</div>
</div>
<a id="aad08a5365795a653696041261c98ab67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad08a5365795a653696041261c98ab67">&#9670;&nbsp;</a></span>M3U_CONTENT_TYPE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::M3U_CONTENT_TYPE = &quot;mpegurl&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The HTML content-type of an M3U playlist. </p>

</div>
</div>
<a id="aad08a5365795a653696041261c98ab67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad08a5365795a653696041261c98ab67">&#9670;&nbsp;</a></span>M3U_CONTENT_TYPE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::M3U_CONTENT_TYPE = &quot;mpegurl&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The HTML content-type of an M3U playlist. </p>

</div>
</div>
<a id="a0de330d59c114114a8c4ccec1dda60a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de330d59c114114a8c4ccec1dda60a0">&#9670;&nbsp;</a></span>METHOD_ATTR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::METHOD_ATTR = &quot;METHOD=&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method encryption attribute. </p>

</div>
</div>
<a id="ae2d8a300fc90d8a970d8fc786089e718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d8a300fc90d8a970d8fc786089e718">&#9670;&nbsp;</a></span>PLS_CONTENT_TYPE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::PLS_CONTENT_TYPE = &quot;scpls&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The HTML content-type of a PLS playlist. </p>

</div>
</div>
<a id="ae2d8a300fc90d8a970d8fc786089e718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d8a300fc90d8a970d8fc786089e718">&#9670;&nbsp;</a></span>PLS_CONTENT_TYPE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::PLS_CONTENT_TYPE = &quot;scpls&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The HTML content-type of a PLS playlist. </p>

</div>
</div>
<a id="ae4ea523dee7ebdc160762ddcd7ff59c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ea523dee7ebdc160762ddcd7ff59c8">&#9670;&nbsp;</a></span>PLS_FILE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::PLS_FILE = &quot;File&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The beginning of a line in a PLS file indicating a URL. </p>

</div>
</div>
<a id="a0eb8f02e86db841d2ea55658c433b86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb8f02e86db841d2ea55658c433b86a">&#9670;&nbsp;</a></span>PLS_PLAYLIST_HEADER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::PLS_PLAYLIST_HEADER = &quot;[playlist]&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first line of a PLS playlist. </p>

</div>
</div>
<a id="ada27ee87af91eab7d05cb1bc765c7b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada27ee87af91eab7d05cb1bc765c7b05">&#9670;&nbsp;</a></span>URI_ATTR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::URI_ATTR = &quot;URI=\&quot;&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>HLS tag attribute for URI. </p>

</div>
</div>
<a id="a3e77b880934e6f5e7a6d4e65f4c4fdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e77b880934e6f5e7a6d4e65f4c4fdb1">&#9670;&nbsp;</a></span>URL_END_SCHEME_PATTERN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string alexaClientSDK::playlistParser::URL_END_SCHEME_PATTERN = &quot;://&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>url scheme pattern. </p>

</div>
</div>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      Project  - Copyright 2016-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
